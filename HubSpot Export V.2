#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
HubSpot Fast Data Exporter - Optimized for Speed
Guarantees all emails and meetings are exported

Setup: pip install requests pandas openpyxl
"""

import os
import sys
import json
import time
from datetime import datetime
from collections import defaultdict

# Check dependencies
try:
    import requests
    import pandas as pd
    from openpyxl import Workbook
except ImportError as e:
    print(f"‚ùå Missing required package: {e}")
    print("Please install: pip install requests pandas openpyxl")
    sys.exit(1)


class HubSpotFastExporter:
    """Optimized HubSpot exporter using batch operations"""
    
    def __init__(self, api_key):
        self.api_key = api_key
        self.base_url = "https://api.hubapi.com"
        self.headers = {
            "Authorization": f"Bearer {api_key}",
            "Content-Type": "application/json"
        }
        # Cache for storing all data
        self.all_contacts = []
        self.all_emails = []
        self.all_meetings = []
        self.contact_email_map = defaultdict(list)
        self.contact_meeting_map = defaultdict(list)
        
    def test_connection(self):
        """Quick connection test"""
        print("\nüîç Testing HubSpot connection...")
        url = f"{self.base_url}/crm/v3/objects/contacts?limit=1"
        
        try:
            response = requests.get(url, headers=self.headers, timeout=10)
            if response.status_code == 200:
                print("‚úÖ Connection successful!")
                return True
            else:
                print(f"‚ùå Connection failed: {response.status_code}")
                if response.status_code == 401:
                    print("   Check your API key (should start with 'pat-na1-')")
                return False
        except Exception as e:
            print(f"‚ùå Connection error: {str(e)}")
            return False
    
    def fetch_all_contacts(self, list_id=None):
        """Fetch all contacts at once"""
        print("\nüì• Fetching contacts...")
        contacts = []
        
        if list_id:
            # Fetch from specific list
            url = f"{self.base_url}/contacts/v1/lists/{list_id}/contacts/all"
            offset = 0
            
            while True:
                params = {
                    "count": 250,  # Max allowed
                    "vidOffset": offset,
                    "property": ["email", "firstname", "lastname", "phone", "company", "lifecyclestage"]
                }
                
                response = requests.get(url, headers=self.headers, params=params)
                if response.status_code != 200:
                    print(f"‚ùå Error fetching list: {response.status_code}")
                    break
                    
                data = response.json()
                batch = data.get("contacts", [])
                contacts.extend(batch)
                
                print(f"   Retrieved {len(contacts)} contacts so far...")
                
                if not data.get("has-more", False):
                    break
                offset = data.get("vid-offset", 0)
        else:
            # Fetch all contacts
            url = f"{self.base_url}/crm/v3/objects/contacts"
            after = None
            
            while True:
                params = {
                    "limit": 100,
                    "properties": "email,firstname,lastname,phone,company,lifecyclestage"
                }
                if after:
                    params["after"] = after
                
                response = requests.get(url, headers=self.headers, params=params)
                if response.status_code != 200:
                    break
                    
                data = response.json()
                batch = data.get("results", [])
                contacts.extend(batch)
                
                print(f"   Retrieved {len(contacts)} contacts so far...")
                
                paging = data.get("paging", {})
                if "next" in paging:
                    after = paging["next"]["after"]
                else:
                    break
        
        # Normalize contact format
        self.all_contacts = []
        for contact in contacts:
            if "vid" in contact:  # v1 format
                contact_data = {
                    "id": str(contact["vid"]),
                    "properties": {}
                }
                props = contact.get("properties", {})
                for key, value in props.items():
                    if isinstance(value, dict):
                        contact_data["properties"][key] = value.get("value", "")
                    else:
                        contact_data["properties"][key] = value
            else:  # v3 format
                contact_data = contact
                
            self.all_contacts.append(contact_data)
        
        print(f"‚úÖ Total contacts loaded: {len(self.all_contacts)}")
        return self.all_contacts
    
    def fetch_all_emails(self):
        """Fetch ALL emails from HubSpot in bulk"""
        print("\nüìß Fetching ALL emails from HubSpot...")
        all_emails = []
        after = None
        
        while True:
            url = f"{self.base_url}/crm/v3/objects/emails"
            params = {
                "limit": 100,
                "properties": "hs_timestamp,hs_email_subject,hs_email_text,hs_email_html," \
                            "hs_email_direction,hs_email_status,hs_email_from,hs_email_to," \
                            "hs_email_cc,hs_email_bcc,hs_email_sender_email,hs_email_sender_name"
            }
            if after:
                params["after"] = after
            
            try:
                response = requests.get(url, headers=self.headers, params=params)
                if response.status_code != 200:
                    print(f"‚ö†Ô∏è  Cannot fetch emails: {response.status_code}")
                    if response.status_code == 403:
                        print("   Need 'Email' read permission in your Private App")
                    break
                
                data = response.json()
                batch = data.get("results", [])
                all_emails.extend(batch)
                
                print(f"   Retrieved {len(all_emails)} emails so far...")
                
                paging = data.get("paging", {})
                if "next" in paging:
                    after = paging["next"]["after"]
                else:
                    break
                    
            except Exception as e:
                print(f"‚ö†Ô∏è  Error fetching emails: {str(e)}")
                break
        
        self.all_emails = all_emails
        print(f"‚úÖ Total emails loaded: {len(self.all_emails)}")
        
        # Now fetch associations for all emails
        if self.all_emails:
            self.fetch_email_associations()
    
    def fetch_email_associations(self):
        """Fetch contact associations for all emails in bulk"""
        print("üîó Linking emails to contacts...")
        
        # Batch process email IDs
        email_ids = [email["id"] for email in self.all_emails]
        batch_size = 100
        
        for i in range(0, len(email_ids), batch_size):
            batch = email_ids[i:i + batch_size]
            
            # Use batch read API
            url = f"{self.base_url}/crm/v3/associations/emails/contacts/batch/read"
            payload = {
                "inputs": [{"id": email_id} for email_id in batch]
            }
            
            try:
                response = requests.post(url, headers=self.headers, json=payload)
                if response.status_code == 200:
                    results = response.json().get("results", [])
                    for result in results:
                        email_id = result.get("from", {}).get("id")
                        associations = result.get("to", [])
                        for assoc in associations:
                            contact_id = assoc.get("id")
                            if contact_id and email_id:
                                # Find the email data
                                email_data = next((e for e in self.all_emails if e["id"] == email_id), None)
                                if email_data:
                                    self.contact_email_map[contact_id].append(email_data)
            except:
                # Fallback to individual lookups if batch fails
                for email_id in batch:
                    self.fetch_single_email_association(email_id)
        
        # Count associations
        total_associations = sum(len(emails) for emails in self.contact_email_map.values())
        print(f"‚úÖ Linked {total_associations} email associations")
    
    def fetch_single_email_association(self, email_id):
        """Fallback method to fetch associations for a single email"""
        try:
            url = f"{self.base_url}/crm/v3/objects/emails/{email_id}/associations/contacts"
            response = requests.get(url, headers=self.headers)
            if response.status_code == 200:
                associations = response.json().get("results", [])
                email_data = next((e for e in self.all_emails if e["id"] == email_id), None)
                if email_data:
                    for assoc in associations:
                        contact_id = assoc.get("id")
                        if contact_id:
                            self.contact_email_map[contact_id].append(email_data)
        except:
            pass
    
    def fetch_all_meetings(self):
        """Fetch ALL meetings from HubSpot in bulk"""
        print("\nüìÖ Fetching ALL meetings from HubSpot...")
        all_meetings = []
        after = None
        
        while True:
            url = f"{self.base_url}/crm/v3/objects/meetings"
            params = {
                "limit": 100,
                "properties": "hs_meeting_title,hs_meeting_body,hs_meeting_start_time," \
                            "hs_meeting_end_time,hs_meeting_outcome,hs_meeting_type," \
                            "hs_meeting_location,hs_attendee_emails,hs_meeting_external_url"
            }
            if after:
                params["after"] = after
            
            try:
                response = requests.get(url, headers=self.headers, params=params)
                if response.status_code != 200:
                    print(f"‚ö†Ô∏è  Cannot fetch meetings: {response.status_code}")
                    if response.status_code == 403:
                        print("   Need 'Meeting' read permission in your Private App")
                    break
                
                data = response.json()
                batch = data.get("results", [])
                all_meetings.extend(batch)
                
                print(f"   Retrieved {len(all_meetings)} meetings so far...")
                
                paging = data.get("paging", {})
                if "next" in paging:
                    after = paging["next"]["after"]
                else:
                    break
                    
            except Exception as e:
                print(f"‚ö†Ô∏è  Error fetching meetings: {str(e)}")
                break
        
        self.all_meetings = all_meetings
        print(f"‚úÖ Total meetings loaded: {len(self.all_meetings)}")
        
        # Now fetch associations
        if self.all_meetings:
            self.fetch_meeting_associations()
    
    def fetch_meeting_associations(self):
        """Fetch contact associations for all meetings in bulk"""
        print("üîó Linking meetings to contacts...")
        
        # Batch process meeting IDs
        meeting_ids = [meeting["id"] for meeting in self.all_meetings]
        batch_size = 100
        
        for i in range(0, len(meeting_ids), batch_size):
            batch = meeting_ids[i:i + batch_size]
            
            # Use batch read API
            url = f"{self.base_url}/crm/v3/associations/meetings/contacts/batch/read"
            payload = {
                "inputs": [{"id": meeting_id} for meeting_id in batch]
            }
            
            try:
                response = requests.post(url, headers=self.headers, json=payload)
                if response.status_code == 200:
                    results = response.json().get("results", [])
                    for result in results:
                        meeting_id = result.get("from", {}).get("id")
                        associations = result.get("to", [])
                        for assoc in associations:
                            contact_id = assoc.get("id")
                            if contact_id and meeting_id:
                                # Find the meeting data
                                meeting_data = next((m for m in self.all_meetings if m["id"] == meeting_id), None)
                                if meeting_data:
                                    self.contact_meeting_map[contact_id].append(meeting_data)
            except:
                # Fallback to individual lookups
                for meeting_id in batch:
                    self.fetch_single_meeting_association(meeting_id)
        
        # Count associations
        total_associations = sum(len(meetings) for meetings in self.contact_meeting_map.values())
        print(f"‚úÖ Linked {total_associations} meeting associations")
    
    def fetch_single_meeting_association(self, meeting_id):
        """Fallback method to fetch associations for a single meeting"""
        try:
            url = f"{self.base_url}/crm/v3/objects/meetings/{meeting_id}/associations/contacts"
            response = requests.get(url, headers=self.headers)
            if response.status_code == 200:
                associations = response.json().get("results", [])
                meeting_data = next((m for m in self.all_meetings if m["id"] == meeting_id), None)
                if meeting_data:
                    for assoc in associations:
                        contact_id = assoc.get("id")
                        if contact_id:
                            self.contact_meeting_map[contact_id].append(meeting_data)
        except:
            pass
    
    def format_timestamp(self, timestamp):
        """Convert timestamp to readable format"""
        if not timestamp:
            return ""
        try:
            dt = datetime.fromisoformat(timestamp.replace('Z', '+00:00'))
            return dt.strftime("%Y-%m-%d %H:%M:%S")
        except:
            return timestamp
    
    def export_to_excel(self, filename="hubspot_fast_export.xlsx", list_id=None):
        """Export all data to Excel"""
        print("\n" + "="*70)
        print("STARTING FAST EXPORT PROCESS")
        print("="*70)
        
        # Test connection
        if not self.test_connection():
            return False
        
        # Fetch all data
        start_time = time.time()
        
        # 1. Fetch contacts
        self.fetch_all_contacts(list_id)
        if not self.all_contacts:
            print("‚ùå No contacts found!")
            return False
        
        # 2. Fetch all emails and meetings
        self.fetch_all_emails()
        self.fetch_all_meetings()
        
        # 3. Prepare data for export
        print("\nüìä Preparing data for Excel export...")
        
        # Contact data
        contact_rows = []
        for contact in self.all_contacts:
            props = contact.get("properties", {})
            contact_id = contact.get("id", "")
            
            # Count associated items
            email_count = len(self.contact_email_map.get(contact_id, []))
            meeting_count = len(self.contact_meeting_map.get(contact_id, []))
            
            contact_rows.append({
                "Contact ID": contact_id,
                "Email": props.get("email", ""),
                "First Name": props.get("firstname", ""),
                "Last Name": props.get("lastname", ""),
                "Phone": props.get("phone", ""),
                "Company": props.get("company", ""),
                "Lifecycle Stage": props.get("lifecyclestage", ""),
                "Total Emails": email_count,
                "Total Meetings": meeting_count,
                "Export Date": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            })
        
        # Email data
        email_rows = []
        for contact_id, emails in self.contact_email_map.items():
            # Find contact info
            contact = next((c for c in self.all_contacts if c.get("id") == contact_id), {})
            contact_props = contact.get("properties", {})
            
            for email in emails:
                props = email.get("properties", {})
                email_rows.append({
                    "Contact ID": contact_id,
                    "Contact Email": contact_props.get("email", ""),
                    "Contact Name": f"{contact_props.get('firstname', '')} {contact_props.get('lastname', '')}".strip(),
                    "Email Subject": props.get("hs_email_subject", ""),
                    "Email Direction": props.get("hs_email_direction", ""),
                    "Email Status": props.get("hs_email_status", ""),
                    "Email Date": self.format_timestamp(props.get("hs_timestamp", "")),
                    "From": props.get("hs_email_from", "") or props.get("hs_email_sender_email", ""),
                    "To": props.get("hs_email_to", ""),
                    "Email Preview": (props.get("hs_email_text", "") or props.get("hs_email_html", ""))[:500]
                })
        
        # Meeting data
        meeting_rows = []
        for contact_id, meetings in self.contact_meeting_map.items():
            # Find contact info
            contact = next((c for c in self.all_contacts if c.get("id") == contact_id), {})
            contact_props = contact.get("properties", {})
            
            for meeting in meetings:
                props = meeting.get("properties", {})
                meeting_rows.append({
                    "Contact ID": contact_id,
                    "Contact Email": contact_props.get("email", ""),
                    "Contact Name": f"{contact_props.get('firstname', '')} {contact_props.get('lastname', '')}".strip(),
                    "Meeting Title": props.get("hs_meeting_title", ""),
                    "Meeting Type": props.get("hs_meeting_type", ""),
                    "Start Time": self.format_timestamp(props.get("hs_meeting_start_time", "")),
                    "End Time": self.format_timestamp(props.get("hs_meeting_end_time", "")),
                    "Location": props.get("hs_meeting_location", ""),
                    "Outcome": props.get("hs_meeting_outcome", ""),
                    "Attendees": props.get("hs_attendee_emails", ""),
                    "Description": (props.get("hs_meeting_body", "") or "")[:500]
                })
        
        # Create Excel file
        try:
            script_dir = os.path.dirname(os.path.abspath(__file__)) if '__file__' in globals() else os.getcwd()
            filepath = os.path.join(script_dir, filename)
            
            with pd.ExcelWriter(filepath, engine='openpyxl') as writer:
                # Summary sheet
                summary_df = pd.DataFrame([{
                    "Export Date": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                    "Total Contacts": len(contact_rows),
                    "Total Emails in HubSpot": len(self.all_emails),
                    "Total Meetings in HubSpot": len(self.all_meetings),
                    "Emails Linked to Contacts": len(email_rows),
                    "Meetings Linked to Contacts": len(meeting_rows),
                    "Contacts with Emails": len([c for c in contact_rows if c["Total Emails"] > 0]),
                    "Contacts with Meetings": len([c for c in contact_rows if c["Total Meetings"] > 0]),
                    "Export Time (seconds)": round(time.time() - start_time, 2)
                }])
                summary_df.to_excel(writer, sheet_name='Summary', index=False)
                
                # Contact sheet
                contact_df = pd.DataFrame(contact_rows)
                contact_df.to_excel(writer, sheet_name='Contacts', index=False)
                
                # Email sheet
                if email_rows:
                    email_df = pd.DataFrame(email_rows)
                    email_df.to_excel(writer, sheet_name='Emails', index=False)
                else:
                    pd.DataFrame({"Note": ["No emails found or no email permissions"]}).to_excel(writer, sheet_name='Emails', index=False)
                
                # Meeting sheet
                if meeting_rows:
                    meeting_df = pd.DataFrame(meeting_rows)
                    meeting_df.to_excel(writer, sheet_name='Meetings', index=False)
                else:
                    pd.DataFrame({"Note": ["No meetings found or no meeting permissions"]}).to_excel(writer, sheet_name='Meetings', index=False)
            
            # Final report
            elapsed_time = round(time.time() - start_time, 2)
            print(f"\n‚úÖ EXPORT COMPLETE in {elapsed_time} seconds!")
            print(f"\nüìä Final Statistics:")
            print(f"   - {len(contact_rows)} contacts exported")
            print(f"   - {len(self.all_emails)} total emails in HubSpot")
            print(f"   - {len(email_rows)} emails linked to contacts")
            print(f"   - {len(self.all_meetings)} total meetings in HubSpot")
            print(f"   - {len(meeting_rows)} meetings linked to contacts")
            print(f"\nüìÅ File saved to: {filepath}")
            
            # Try to open folder
            if os.name == 'nt':
                try:
                    os.startfile(script_dir)
                except:
                    pass
            
            return True
            
        except Exception as e:
            print(f"\n‚ùå Error creating Excel file: {str(e)}")
            return False


def main():
    """Main function"""
    print("="*70)
    print("HUBSPOT FAST DATA EXPORTER")
    print("Optimized for speed - Exports all emails and meetings")
    print("="*70)
    
    # Get API key
    API_KEY = os.environ.get('HUBSPOT_API_KEY', '').strip()
    
    if not API_KEY:
        print("\n‚ö†Ô∏è  No API key found in environment variable")
        API_KEY = input("Enter your HubSpot Private App token: ").strip()
    
    if not API_KEY:
        print("‚ùå No API key provided.")
        return 1
    
    # Create exporter
    exporter = HubSpotFastExporter(API_KEY)
    
    # Simple menu
    print("\nOptions:")
    print("1. Export ALL contacts with emails/meetings")
    print("2. Export specific list")
    print("3. Exit")
    
    choice = input("\nYour choice (1-3): ").strip()
    
    if choice == "1":
        filename = input("Filename (default: hubspot_all_data.xlsx): ").strip() or "hubspot_all_data.xlsx"
        exporter.export_to_excel(filename)
        
    elif choice == "2":
        list_id = input("Enter List ID: ").strip()
        if list_id:
            filename = input("Filename (default: hubspot_list_data.xlsx): ").strip() or "hubspot_list_data.xlsx"
            exporter.export_to_excel(filename, list_id=list_id)
        else:
            print("‚ùå No list ID provided")
            
    elif choice == "3":
        print("Goodbye!")
        return 0
    
    return 0


if __name__ == "__main__":
    try:
        sys.exit(main())
    except KeyboardInterrupt:
        print("\n\nCancelled by user.")
        sys.exit(0)
    except Exception as e:
        print(f"\n‚ùå Error: {str(e)}")
        sys.exit(1)
