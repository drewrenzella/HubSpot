import requests
import pandas as pd
from datetime import datetime
import json
import os
import time
from openpyxl import load_workbook
from openpyxl.styles import PatternFill, Font
from openpyxl.utils.dataframe import dataframe_to_rows

class HubSpotCompleteExporter:
    def __init__(self, api_key, debug=True):
        self.api_key = api_key
        self.base_url = "https://api.hubapi.com"
        self.headers = {
            "Authorization": f"Bearer {api_key}",
            "Content-Type": "application/json"
        }
        self.debug = debug
        self.association_types_cache = {}
        
    def test_connection(self):
        """Test API connection and all required permissions"""
        print("\nüîç Testing HubSpot API connection...")
        print(f"   API Key: {self.api_key[:20]}..." if len(self.api_key) > 20 else f"   API Key: {self.api_key}")
        
        # Test basic connection
        url = f"{self.base_url}/crm/v3/objects/contacts?limit=1"
        response = requests.get(url, headers=self.headers)
        
        if response.status_code != 200:
            print(f"‚ùå Authentication failed! Status: {response.status_code}")
            return False
            
        print("‚úÖ API connection successful!")
        
        # Test various object access
        objects_to_test = {
            "emails": "Email",
            "meetings": "Meeting",
            "notes": "Notes (for READ AI)",
            "calls": "Calls",
            "tasks": "Tasks"
        }
        
        print("\nüìã Testing object access permissions:")
        accessible_objects = []
        
        for obj, name in objects_to_test.items():
            url = f"{self.base_url}/crm/v3/objects/{obj}?limit=1"
            response = requests.get(url, headers=self.headers)
            if response.status_code == 200:
                print(f"   ‚úÖ {name} access granted")
                accessible_objects.append(obj)
            else:
                print(f"   ‚ùå {name} access denied (status: {response.status_code})")
                
        # Get association types
        print("\nüîó Fetching association types...")
        self.get_association_types()
        
        return True
    
    def get_association_types(self):
        """Get all available association types between contacts and other objects"""
        try:
            # Get association types for contacts to emails
            url = f"{self.base_url}/crm/v4/associations/contacts/emails/labels"
            response = requests.get(url, headers=self.headers)
            if response.status_code == 200:
                self.association_types_cache['emails'] = response.json().get('results', [])
                if self.debug:
                    print(f"   Found {len(self.association_types_cache['emails'])} email association types")
            
            # Get association types for contacts to meetings
            url = f"{self.base_url}/crm/v4/associations/contacts/meetings/labels"
            response = requests.get(url, headers=self.headers)
            if response.status_code == 200:
                self.association_types_cache['meetings'] = response.json().get('results', [])
                if self.debug:
                    print(f"   Found {len(self.association_types_cache['meetings'])} meeting association types")
                    
        except Exception as e:
            if self.debug:
                print(f"   Note: Could not fetch association types (using defaults): {str(e)}")
    
    def get_all_associations_for_contact(self, contact_id):
        """Get ALL associations for a contact using both v3 and v4 APIs"""
        associations = {
            'emails': [],
            'meetings': [],
            'notes': [],
            'calls': [],
            'tasks': []
        }
        
        # Try v4 API first (more comprehensive)
        try:
            url = f"{self.base_url}/crm/v4/objects/contacts/{contact_id}/associations/emails"
            response = requests.get(url, headers=self.headers)
            if response.status_code == 200:
                associations['emails'] = response.json().get('results', [])
        except:
            pass
            
        # Also try v3 API for each object type
        for obj_type in associations.keys():
            try:
                url = f"{self.base_url}/crm/v3/objects/contacts/{contact_id}/associations/{obj_type}"
                response = requests.get(url, headers=self.headers)
                if response.status_code == 200:
                    v3_results = response.json().get('results', [])
                    # Merge with v4 results, avoiding duplicates
                    existing_ids = {item.get('toObjectId', item.get('id')) for item in associations[obj_type]}
                    for item in v3_results:
                        if item.get('id') not in existing_ids:
                            associations[obj_type].append(item)
            except:
                pass
                
        return associations
    
    def get_emails_for_contact(self, contact_id):
        """Fetch all emails associated with a contact with improved detection"""
        all_emails = []
        
        # Get associations
        associations = self.get_all_associations_for_contact(contact_id)
        email_ids = []
        
        # Extract email IDs from associations
        for assoc in associations.get('emails', []):
            email_id = assoc.get('toObjectId') or assoc.get('id')
            if email_id:
                email_ids.append(email_id)
        
        # Fetch email details
        for email_id in email_ids:
            try:
                url = f"{self.base_url}/crm/v3/objects/emails/{email_id}"
                # Request ALL properties
                params = {"properties": "*"}
                response = requests.get(url, headers=self.headers, params=params)
                
                if response.status_code == 200:
                    email_data = response.json()
                    all_emails.append(email_data)
            except Exception as e:
                if self.debug:
                    print(f"      Error fetching email {email_id}: {str(e)}")
                    
        return all_emails
    
    def get_meetings_for_contact(self, contact_id):
        """Fetch all meetings associated with a contact with improved detection"""
        all_meetings = []
        
        # Get associations
        associations = self.get_all_associations_for_contact(contact_id)
        meeting_ids = []
        
        # Extract meeting IDs
        for assoc in associations.get('meetings', []):
            meeting_id = assoc.get('toObjectId') or assoc.get('id')
            if meeting_id:
                meeting_ids.append(meeting_id)
        
        # Fetch meeting details
        for meeting_id in meeting_ids:
            try:
                url = f"{self.base_url}/crm/v3/objects/meetings/{meeting_id}"
                # Request ALL properties
                params = {"properties": "*"}
                response = requests.get(url, headers=self.headers, params=params)
                
                if response.status_code == 200:
                    meeting_data = response.json()
                    all_meetings.append(meeting_data)
            except Exception as e:
                if self.debug:
                    print(f"      Error fetching meeting {meeting_id}: {str(e)}")
                    
        return all_meetings
    
    def get_notes_for_contact(self, contact_id):
        """Fetch all notes (including READ AI summaries) for a contact"""
        all_notes = []
        
        # Get associations
        associations = self.get_all_associations_for_contact(contact_id)
        note_ids = []
        
        # Extract note IDs
        for assoc in associations.get('notes', []):
            note_id = assoc.get('toObjectId') or assoc.get('id')
            if note_id:
                note_ids.append(note_id)
        
        # Fetch note details
        for note_id in note_ids:
            try:
                url = f"{self.base_url}/crm/v3/objects/notes/{note_id}"
                params = {"properties": "*"}
                response = requests.get(url, headers=self.headers, params=params)
                
                if response.status_code == 200:
                    note_data = response.json()
                    all_notes.append(note_data)
            except:
                pass
                
        return all_notes
    
    def get_contact_timeline(self, contact_id):
        """Get complete timeline of activities for a contact"""
        timeline_data = {
            'total_emails': 0,
            'total_meetings': 0,
            'total_notes': 0,
            'has_read_ai': False,
            'read_ai_summaries': []
        }
        
        try:
            # Get emails
            emails = self.get_emails_for_contact(contact_id)
            timeline_data['total_emails'] = len(emails)
            
            # Get meetings
            meetings = self.get_meetings_for_contact(contact_id)
            timeline_data['total_meetings'] = len(meetings)
            
            # Get notes (including READ AI)
            notes = self.get_notes_for_contact(contact_id)
            timeline_data['total_notes'] = len(notes)
            
            # Check for READ AI summaries in notes
            for note in notes:
                props = note.get('properties', {})
                note_body = props.get('hs_note_body', '') or ''
                # Look for READ AI indicators
                if any(indicator in note_body.lower() for indicator in ['read ai', 'read.ai', 'meeting summary', 'ai summary']):
                    timeline_data['has_read_ai'] = True
                    timeline_data['read_ai_summaries'].append({
                        'date': props.get('hs_timestamp', ''),
                        'summary': note_body[:500] + '...' if len(note_body) > 500 else note_body
                    })
                    
        except Exception as e:
            if self.debug:
                print(f"      Error getting timeline for contact {contact_id}: {str(e)}")
                
        return timeline_data
    
    def get_contacts_from_list(self, list_id, limit=100):
        """Fetch contacts from a specific list"""
        contacts = []
        offset = 0
        page = 1
        
        print(f"\nüì• Fetching contacts from list {list_id}...")
        
        while True:
            url = f"{self.base_url}/contacts/v1/lists/{list_id}/contacts/all"
            params = {
                "count": limit,
                "vidOffset": offset,
                "property": ["email", "firstname", "lastname", "phone", "company", 
                           "lifecyclestage", "hs_lead_status", "notes_last_updated", 
                           "num_associated_deals", "recent_deal_amount"]
            }
            
            try:
                response = requests.get(url, headers=self.headers, params=params)
                
                if response.status_code != 200:
                    print(f"‚ùå Error fetching contacts: {response.status_code}")
                    break
                
                data = response.json()
                page_contacts = data.get("contacts", [])
                contacts.extend(page_contacts)
                
                print(f"   Page {page}: Retrieved {len(page_contacts)} contacts")
                
                if data.get("has-more", False):
                    offset = data.get("vid-offset", 0)
                    page += 1
                else:
                    break
                    
            except Exception as e:
                print(f"‚ùå Exception occurred: {str(e)}")
                break
        
        # Convert to v3 format
        v3_contacts = []
        for contact in contacts:
            v3_contact = {
                "id": str(contact.get("vid", "")),
                "properties": {}
            }
            
            # Flatten properties
            props = contact.get("properties", {})
            for prop, value in props.items():
                if isinstance(value, dict):
                    v3_contact["properties"][prop] = value.get("value", "")
                else:
                    v3_contact["properties"][prop] = value
            
            v3_contacts.append(v3_contact)
        
        print(f"‚úÖ Total contacts retrieved: {len(v3_contacts)}")
        return v3_contacts
    
    def process_contacts_with_details(self, contacts):
        """Process contacts and fetch all associated data"""
        contact_data = []
        email_data = []
        meeting_data = []
        read_ai_data = []
        
        print(f"\nüìä Processing {len(contacts)} contacts with full details...")
        print("   This will fetch emails, meetings, notes, and READ AI summaries")
        
        for i, contact in enumerate(contacts):
            # Progress indicator
            if i == 0 or (i + 1) % 5 == 0 or i == len(contacts) - 1:
                print(f"   Progress: {i+1}/{len(contacts)} contacts processed...")
            
            contact_id = contact.get("id", "")
            properties = contact.get("properties", {})
            
            # Get timeline data for this contact
            timeline = self.get_contact_timeline(contact_id)
            
            # Basic contact info with timeline summary
            contact_info = {
                "Contact ID": contact_id,
                "Email": properties.get("email", ""),
                "First Name": properties.get("firstname", ""),
                "Last Name": properties.get("lastname", ""),
                "Phone": properties.get("phone", ""),
                "Company": properties.get("company", ""),
                "Lifecycle Stage": properties.get("lifecyclestage", ""),
                "Lead Status": properties.get("hs_lead_status", ""),
                "Total Emails": timeline['total_emails'],
                "Total Meetings": timeline['total_meetings'],
                "Total Notes": timeline['total_notes'],
                "Has READ AI": "Yes" if timeline['has_read_ai'] else "No",
                "Last Updated": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            }
            contact_data.append(contact_info)
            
            # Process emails
            emails = self.get_emails_for_contact(contact_id)
            for email in emails:
                props = email.get('properties', {})
                email_info = {
                    "Contact ID": contact_id,
                    "Contact Email": properties.get("email", ""),
                    "Contact Name": f"{properties.get('firstname', '')} {properties.get('lastname', '')}".strip(),
                    "Email Subject": props.get("hs_email_subject", ""),
                    "Email Direction": props.get("hs_email_direction", ""),
                    "Email Status": props.get("hs_email_status", ""),
                    "Email Date": self.format_timestamp(props.get("hs_timestamp", "")),
                    "From": props.get("hs_email_from", ""),
                    "To": props.get("hs_email_to", ""),
                    "Email Body Preview": (props.get("hs_email_text", "") or props.get("hs_email_html_text", ""))[:500] + "..."
                }
                email_data.append(email_info)
            
            # Process meetings
            meetings = self.get_meetings_for_contact(contact_id)
            for meeting in meetings:
                props = meeting.get('properties', {})
                meeting_info = {
                    "Contact ID": contact_id,
                    "Contact Email": properties.get("email", ""),
                    "Contact Name": f"{properties.get('firstname', '')} {properties.get('lastname', '')}".strip(),
                    "Meeting Title": props.get("hs_meeting_title", ""),
                    "Meeting Type": props.get("hs_meeting_type", ""),
                    "Meeting Start": self.format_timestamp(props.get("hs_meeting_start_time", "")),
                    "Meeting End": self.format_timestamp(props.get("hs_meeting_end_time", "")),
                    "Duration (min)": props.get("hs_meeting_duration_minutes", ""),
                    "Meeting Location": props.get("hs_meeting_location", ""),
                    "Meeting Outcome": props.get("hs_meeting_outcome", ""),
                    "Attendees": props.get("hs_attendee_emails", ""),
                    "Meeting Description": (props.get("hs_meeting_body", "") or "")[:500] + "..."
                }
                meeting_data.append(meeting_info)
            
            # Process READ AI summaries
            for summary in timeline['read_ai_summaries']:
                read_ai_info = {
                    "Contact ID": contact_id,
                    "Contact Email": properties.get("email", ""),
                    "Contact Name": f"{properties.get('firstname', '')} {properties.get('lastname', '')}".strip(),
                    "Summary Date": self.format_timestamp(summary['date']),
                    "READ AI Summary": summary['summary']
                }
                read_ai_data.append(read_ai_info)
        
        print(f"\n‚úÖ Processing complete!")
        print(f"   - {len(email_data)} emails found")
        print(f"   - {len(meeting_data)} meetings found")
        print(f"   - {len(read_ai_data)} READ AI summaries found")
        
        return contact_data, email_data, meeting_data, read_ai_data
    
    def export_to_excel(self, filename="hubspot_complete_export.xlsx", list_id=None, list_name=None):
        """Export all data to Excel with comprehensive information"""
        
        # Test connection first
        if not self.test_connection():
            print("\n‚ùå Cannot proceed without valid connection.")
            return False
        
        # Get contacts
        if list_id:
            contacts = self.get_contacts_from_list(list_id)
            export_type = f"List: {list_name or list_id}"
        else:
            print("\nüì• Fetching all contacts...")
            # For all contacts, use the v3 API
            contacts = []
            after = None
            while True:
                url = f"{self.base_url}/crm/v3/objects/contacts"
                params = {"limit": 100}
                if after:
                    params["after"] = after
                
                response = requests.get(url, headers=self.headers, params=params)
                if response.status_code == 200:
                    data = response.json()
                    contacts.extend(data.get("results", []))
                    
                    if "paging" in data and "next" in data["paging"]:
                        after = data["paging"]["next"]["after"]
                    else:
                        break
                else:
                    break
            export_type = "All Contacts"
        
        if not contacts:
            print("\n‚ö†Ô∏è  No contacts found!")
            return False
        
        # Process all contacts with their details
        contact_data, email_data, meeting_data, read_ai_data = self.process_contacts_with_details(contacts)
        
        # Create DataFrames
        contact_df = pd.DataFrame(contact_data)
        email_df = pd.DataFrame(email_data) if email_data else pd.DataFrame()
        meeting_df = pd.DataFrame(meeting_data) if meeting_data else pd.DataFrame()
        read_ai_df = pd.DataFrame(read_ai_data) if read_ai_data else pd.DataFrame()
        
        # Create summary DataFrame
        summary_df = contact_df.copy()
        
        # Save to Excel
        script_dir = os.path.dirname(os.path.abspath(__file__))
        full_filepath = os.path.join(script_dir, filename)
        
        print(f"\nüíæ Saving to: {full_filepath}")
        
        try:
            with pd.ExcelWriter(full_filepath, engine='openpyxl') as writer:
                # Export Info
                metadata = pd.DataFrame([{
                    "Export Date": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                    "Export Type": export_type,
                    "Total Contacts": len(contact_df),
                    "Total Emails": len(email_df),
                    "Total Meetings": len(meeting_df),
                    "Total READ AI Summaries": len(read_ai_df),
                    "Contacts with Emails": len(contact_df[contact_df['Total Emails'] > 0]),
                    "Contacts with Meetings": len(contact_df[contact_df['Total Meetings'] > 0]),
                    "Contacts with READ AI": len(contact_df[contact_df['Has READ AI'] == 'Yes'])
                }])
                metadata.to_excel(writer, sheet_name='Export Info', index=False)
                
                # Write data sheets
                summary_df.to_excel(writer, sheet_name='Contact Summary', index=False)
                contact_df.to_excel(writer, sheet_name='Contacts', index=False)
                
                if not email_df.empty:
                    email_df.to_excel(writer, sheet_name='Emails', index=False)
                else:
                    pd.DataFrame({"Note": ["No emails found"]}).to_excel(writer, sheet_name='Emails', index=False)
                
                if not meeting_df.empty:
                    meeting_df.to_excel(writer, sheet_name='Meetings', index=False)
                else:
                    pd.DataFrame({"Note": ["No meetings found"]}).to_excel(writer, sheet_name='Meetings', index=False)
                
                if not read_ai_df.empty:
                    read_ai_df.to_excel(writer, sheet_name='READ AI Summaries', index=False)
                else:
                    pd.DataFrame({"Note": ["No READ AI summaries found"]}).to_excel(writer, sheet_name='READ AI Summaries', index=False)
            
            print(f"\n‚úÖ Export complete!")
            print(f"üìä Final Summary:")
            print(f"   - {len(contact_df)} contacts exported")
            print(f"   - {len(email_df)} emails")
            print(f"   - {len(meeting_df)} meetings")
            print(f"   - {len(read_ai_df)} READ AI summaries")
            
            # Open folder
            if os.name == 'nt':
                os.startfile(script_dir)
            
            return True
            
        except Exception as e:
            print(f"\n‚ùå Error writing Excel file: {str(e)}")
            return False
    
    def format_timestamp(self, timestamp):
        """Convert HubSpot timestamp to readable date"""
        if not timestamp:
            return ""
        try:
            dt = datetime.fromisoformat(timestamp.replace('Z', '+00:00'))
            return dt.strftime("%Y-%m-%d %H:%M:%S")
        except:
            return timestamp


def main():
    """Main function to run the exporter"""
    print("=" * 70)
    print("HUBSPOT COMPLETE DATA EXPORTER")
    print("Exports: Contacts, Emails, Meetings, and READ AI Summaries")
    print("=" * 70)
    
    # Get API key
    API_KEY = os.environ.get('HUBSPOT_API_KEY', '')
    
    if not API_KEY:
        print("\n‚ö†Ô∏è  No API key found in environment variable HUBSPOT_API_KEY")
        API_KEY = input("Please enter your HubSpot Private App token: ").strip()
    
    if not API_KEY:
        print("‚ùå No API key provided. Exiting.")
        return
    
    # Create exporter
    exporter = HubSpotCompleteExporter(API_KEY, debug=True)
    
    # Menu
    while True:
        print("\n" + "=" * 70)
        print("OPTIONS:")
        print("1. Test connection and permissions")
        print("2. Export contacts from a specific list")
        print("3. Export ALL contacts") 
        print("4. Quick export (specific list, no prompt)")
        print("5. Exit")
        print("=" * 70)
        
        choice = input("\nEnter your choice (1-5): ").strip()
        
        if choice == '1':
            exporter.test_connection()
            input("\nPress Enter to continue...")
            
        elif choice == '2':
            list_id = input("\nEnter the List ID: ").strip()
            list_name = input("Enter a friendly name for this list (optional): ").strip()
            filename = input("Enter filename (default: hubspot_export.xlsx): ").strip() or "hubspot_export.xlsx"
            
            exporter.export_to_excel(
                filename=filename,
                list_id=list_id,
                list_name=list_name
            )
            
        elif choice == '3':
            filename = input("\nEnter filename (default: all_contacts_export.xlsx): ").strip() or "all_contacts_export.xlsx"
            exporter.export_to_excel(filename=filename)
            
        elif choice == '4':
            # Quick export with defaults
            LIST_ID = "2"  # Change this to your list ID
            exporter.export_to_excel(
                filename="quick_export.xlsx",
                list_id=LIST_ID,
                list_name="Quick Export"
            )
            
        elif choice == '5':
            print("\nGoodbye!")
            break
        
        else:
            print("\n‚ùå Invalid choice. Please try again.")


if __name__ == "__main__":
    # Option 1: Run interactive menu
    main()
    
    # Option 2: Direct export (uncomment and modify as needed)
    # API_KEY = "your-token-here"
    # exporter = HubSpotCompleteExporter(API_KEY, debug=True)
    # exporter.export_to_excel(
    #     filename="my_complete_export.xlsx",
    #     list_id="2",
    #     list_name="My Important Contacts"
    # )
